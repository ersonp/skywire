# Skywire Authentication Protocol

## Key Exchange Protocol

Before the authentication process starts we first share the keys in order to generate the shared secret via `ECDH`.
The Visor A trying the connect to the Visor B sends 
```
type SharedSecretProtocolPacket struct {
    RequestID           uuid.UUID
    PublicKey           cipher.PubKey
    SharedSecretPK      cipher.PubKey
}
```

via the RPC `SharedSecretProtocol` the Visor A will send the Visor B it's details.
- The Visor A will send this first to the Visor B where the `RequestID` will be generated by the Visor A.
- The `PublicKey` is the public key of the Visor A.
- The `SharedSecretPK` is generated everytime with `pk, sk := cipher.GenerateKeyPair()` where the `SharedSecretPK` is sent to the Visor B to be used for encryption and the `SharedSecretSK` is saved on the Visor A to be used for decryption.
- The `ChallengeSalt` is left blank for the Visor A.

The Response of this RPC is sent by the Visor B using the same struct. Before that it checks to see if the `PublicKey` received from `SharedSecretProtocolPacket` matches the `PublicKey` from the dmsg connection.<br>
If it does then the response is sent or else it sends error.
- The `RequestID` in the response is the same as what was received.
- The `PublicKey` is the public key of the Visor B.
- The `SharedSecretPK` is generated everytime with `pk, sk := cipher.GenerateKeyPair()` where the `SharedSecretPK` is sent to the Visor A to be used for decryption and the `SharedSecretSK` is saved on the Visor B to be used for encryption.

## Authentication Protocol

The Visor A then requests for the challenge via the RPC `RequestChallenge` and receives the following struct in response from Visor B
```
type IdentityAuthentication struct {
    RequestID           uuid.UUID
    Challenge           []byte
    Response            []byte
}
```
- For encryption we use (encrypt.DefaultScryptChacha20poly1305)[https://github.com/skycoin/skycoin/blob/v0.27.1/src/cipher/encrypt/scrypt_chacha20poly1305.go#L47]
- Shared secret is generated with the `SharedSecretPK` of Visor A and `SharedSecretSK` of Visor B with (cipher.ECDH)[https://github.com/skycoin/skycoin/blob/v0.27.1/src/cipher/crypto.go#L282]
- In Visor B a random 256 bit number `ChallengeNum` is generated and is encrypted with (encrypt)[https://github.com/skycoin/skycoin/blob/v0.27.1/src/cipher/encrypt/scrypt_chacha20poly1305.go#L77] where the password is the shared secret.
- The encrypted output is then sent to Visor A via `IdentityAuthentication`
- The `Response` field is blank

The visor A then decrypts the Challenge
- By first generating the shared secret with `SharedSecretPK` of Visor B and `SharedSecretSK` of Visor A with (cipher.ECDH)[https://github.com/skycoin/skycoin/blob/v0.27.1/src/cipher/crypto.go#L282]
- Then decrypts the challenge with (decrypt)[https://github.com/skycoin/skycoin/blob/v0.27.1/src/cipher/encrypt/scrypt_chacha20poly1305.go#L134] where the password is the shared secret.
- The decrypted challenge then is then hashed with (cipher.SumSHA256)[https://github.com/skycoin/skycoin/blob/v0.27.1/src/cipher/hash.go#L158]
- Then the hash is encrypted with (encrypt)[https://github.com/skycoin/skycoin/blob/v0.27.1/src/cipher/encrypt/scrypt_chacha20poly1305.go#L77] where the password is the shared secret.
- It is then sent to Visor B with the RPC `ChallengeResponse` using the struct `IdentityAuthentication` where the field `Challenge` is blank and the encrypted hash is in `Response`.

When the visor B receives the Challenge
- It decrypts the response with (decrypt)[https://github.com/skycoin/skycoin/blob/v0.27.1/src/cipher/encrypt/scrypt_chacha20poly1305.go#L134] where the password is the shared secret.
- Then compares the decrypted hash from the response with the hash of `ChallengeNum`
- If it matches then the Identity Authentication is completed and no error is sent in response to the RPC `ChallengeResponse`
- If it doesn't match or if there is an error on any step then the error is sent back to visor A and the connection is closed.